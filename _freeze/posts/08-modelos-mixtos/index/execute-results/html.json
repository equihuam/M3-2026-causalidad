{
  "hash": "3a918a0307442d735dc0990b709eedc6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Modelos de Efectos Mixtos\"\nauthor: [\"Miguel Equihua\"]\ndate: \"2026-02-05\"\nlang: es\ndraft: false\ncategories: [clase]\nformat:\n  html:\n    code-fold: true\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n## Diseños con multiples niveles de unidades experimentales\n\nHay situaciones en las que un estudio requiere considerar unidades\nexperimentales múltiples. Por ejemplo, si estamos haciendo un estudio en\nparcelas forestales y las parcelas son sujetas a tratamientos,\nclaramente esas parcelas son las unidades experimentales de primera\nmano.\n\nSin embargo, imaginemos que la variable de respuesta es el contenido de\nnitrógeno en el suelo, Es poco práctico recolectar la totalidad del\nsuelo hasta, digamos 15cm de profundidad de cada parcela para determinar\nel contenido de nitrógeno en el suelo de toda la parcela.\n\n::: {.callout-caution title=\"¿Qué opciones tenemos?\" collapse=\"true\"}\n[![](images/june16-2015-pg-aerial.jpg){height=\"400px\"}](https://www.nature.com/articles/nature16444)\n\nExiste ayuda en R para el diseño de experimentos, como podemos ver en\n[este preprint](https://arxiv.org/pdf/2311.09705.pdf)\n:::\n\nLa opción natural sería en este caso *tomar una muestra de suelo* en\ncada parcela, y hacer las determinaciones de contenido de nitrógeno en\nellas. Al hacer esto, no conoceremos el contenido de nitrógeno de las\nparcelas, lo estimaremos con un margen de error, es decir con un\ncomponente de varianza asociado con el procedimiento de muestreo. Las\nmuestras son lo que podríamos llamar *unidades experimentales pequeñas*\nque, además del efecto del tratamiento son afectadas por el\nprocedimiento de muestreo como factor adicional.\n\n![](images/arboles.jpeg){width=\"500\"}\n\nOtra situación es, por ejemplo, un experimento sobre el efecto del\ncambio climático sobre la fotosíntesis de árboles sujetos a distintos\nniveles de fertilizante. La situación se complica porque lo que interesa\nes saber si el incremento en la temperatura afecta el contenido de\nnitrógeno en las hojas, para lo cual se opta por hacerlo mediante un\nmuestreo en el que se eligen ramas en cada árbol para exponerlas a una\natmósfera a temperaturas controladas. ¿Cuantas hojas habríamos de\nutilizar para hacer las determinaciones confiablemente?\n\nLos árboles son unidades experimentales *grandes* tratadas con\nfertilizante y las ramas son unidades experimentales *chicas* que\nreciben el tratamiento factorial *fertilizante* + *temperatura*. Además\nhay que notar que muy probablemente hay un efecto \"idiosincrático\" del\nárbol que genera variación en el comportamiento de las ramas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparcela_dividida <- dagitty('dag{bb=\"0,0,1,1\"\n                                 \"aleat-1\" [latent,pos=\"0.4, 0.2\"]\n                                 \"aleat-2\" [latent,pos=\"0.6, 0.2\"]\n                                 \"árbol\" [pos=\"0.4, 0.3\"]\n                                 fert [exposure,pos=\"0.2, 0.3\"]\n                                 hojasN [outcome,pos=\"0.8, 0.3\"]\n                                 rama [pos=\"0.6, 0.3\"]\n                                 temp [exposure,pos=\"0.6, 0.4\"]\n                                 \"aleat-1\" -> \"árbol\"\n                                 \"aleat-2\" -> rama\n                                 \"árbol\" -> rama\n                                 fert -> \"árbol\"\n                                 rama -> hojasN\n                                 temp -> rama}')\npar(cex = 0.75, lwd  = 1)\nplot(parcela_dividida)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/dag_árbol-1.png){width=192}\n:::\n:::\n\n\n# Modelos Lineales de efectos mixtos\n\n## Ejemplo de rieles\n\n::: {.callout-note title=\"Calidad de rieles de ferrocarril\" collapse=\"true\"}\nUno de los principales problemas que enfrentan los ferrocarriles es la\nfalla en las vías. Los defectos en los raíles, como parte básica de la\nvía, pueden provocar accidentes graves. La inspección de los rieles es\ncrítica, considerando el enorme tráfico que soportan actualmente, la\nmayor velocidad y las cargas más pesadas. La inspección visual sólo\npuede detectar defectos superficiales y, a veces, signos evidentes de\nproblemas internos, la *defectoscopía ultrasónica* desempeña un papel\ninsustituible en la inspección de los rieles durante su funcionamiento.\n\n![](images/ultrasonic-railway-rail-testing-01.jpg){wdth=\"60%\"}\n\n[Este ejemplo se explica en este\nlibro](https://faculty.ksu.edu.sa/sites/default/files/probability_and_statistics_for_engineering_and_the_sciences.pdf).\n:::\n\nEl estudio de las fuerzas y tensiones no destructivas en los materiales\nproporciona información importante para un diseño de ingeniería eficaz.\nEl artículo *Zero-Force Travel-Time Parameters for Ultrasonic Head-Waves\nin Railroad* (Materials Evaluation, 1985: 854-858) reporta un estudio\ndel **tiempo de tránsito** de un *cierto tipo de onda* que se obtiene al\nsometer rieles de ferrocarril a esfuerzos de tensión longitudinal. Se\nrealizaron tres mediciones en cada uno de seis rieles seleccionados\naleatoriamente de una población más amplia de ellos. Los investigadores\nbuscaban caracterizar la variación en el tiempo de viaje como referencia\npara describir la *variabilidad* ***típica*** *entre los rieles* que\nestaban adquiriendo y usando. Los ingenieros se interesaban en precisar\nla variabilidad atribuible al ejercicio de realizar las mediciones en un\nmismo riel y la variabilidad que expresan los distintos rieles. Los\ndatos son valores en nanosegundos, resultado de restar 36.1 $\\mu s$ a\ncada observación.\n\nEste ejemplo es un caso simple de efectos aleatorios. En resumen, seis\nrieles fueron tomados al azar y sometidos a prueba tres veces cada uno\nmediante la medición del tiempo que le toma a cierto tipo de ondas\nultrasónicas viajar a lo largo del riel. La Única *condición\nexperimental* que cambia entre observaciones es el riel.\n\nClaramente el estudio tiene un solo criterio de clasificación, como\nposible condición de contraste. La intención del estudio fue la\ndeterminación de:\n\n1.  **Tiempo de tránsito \"típico\"** de un riel (tiempo esperado de\n    tránsito)\n2.  *Variación* en el tiempo de tránsito promedio *entre los rieles*\n    (variabilidad entre rieles)\n3.  *Variación al medir* el tiempo observado de tránsito *en un mismo\n    riel* (variabilidad dentro de rieles)\n\n$$\ny_{ij} = \\mu + \\beta_{1} R_{i} + \\varepsilon_{i(j)}\n$$\n\nUtilizaremos la biblioteca `nlme` (*Linear and Nonlinear Mixed Effects\nModels*, de tipo Gausiano o normal) para ajustar los modelos de *efectos\nmixtos*.\n\nComo hemos estado viendo, actualmente resulta casi obligatorio recurrir\na `ggplot2` para producir gráficas con *calidad publicación*. Esta\nbiblioteca pone en práctica la propuesta que hacen sus autores de una\nsemántica de graficación, la que [Hadley Wickham explica originamente en\nsu libro publicado en\n2009](https://link.springer.com/book/10.1007/978-0-387-98141-3).\nActualmente Hadley trabaja con otros dos coautores (Danielle Navarro y\nThomas Lin Pedersen) en al 3ra. edición, lo hacen como un [*preprint*\nque pueden encontrar aquí](https://ggplot2-book.org/). La gran\ninfluencia de este planteamiento a la producción de gráficas de datos ha\ndado lugar a muchas ideas y recursos de ayuda que fácilmente se pueden\nencontrar en *la Web*.\n\nlos datos con los que trabajaremos en esta sesión están en la tabla\n`Rail` de la biblioteca *nlme*. Para acomodarlos a mis propósitos los\ncopie a mi espacio de trabajo y los guardé en una variable con un nombre\nde mi gusto. Los datos de los rieles están ordenados según fueron\nensayados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nlme)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAdjuntando el paquete: 'nlme'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:dplyr':\n\n    collapse\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(lattice)\nlibrary(ggplot2)\n\nrieles <- Rail\nnames(rieles) <- c(\"riel\", \"viaje\")\nstr(rieles)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'nffGroupedData', 'nfGroupedData', 'groupedData' and 'data.frame':\t18 obs. of  2 variables:\n $ riel : Ord.factor w/ 6 levels \"2\"<\"5\"<\"1\"<\"6\"<..: 3 3 3 1 1 1 5 5 5 6 ...\n $ viaje: num  55 53 54 26 37 32 78 91 85 92 ...\n - attr(*, \"labels\")=List of 1\n  ..$ y: chr \"Zero-force travel time\"\n - attr(*, \"units\")=List of 1\n  ..$ y: chr \"(nanoseconds)\"\n - attr(*, \"formula\")=Class 'formula'  language travel ~ 1 | Rail\n  .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n - attr(*, \"order.groups\")= logi TRUE\n```\n\n\n:::\n:::\n\n\nLa tabla `rieles` fue creada como una **estructura agrupada** con la\nfunción `groupeData` de la biblioteca `nlme`. Veremos más adelante como\nusar esta función. Esta función agrega *metadatos* a la tabla. Si\ninteresa hacer cambios a los *metadatos* de la tabla agrupada hay que\nusar la función `update` que ejemplificaré a continuación. Lo primero es\nexplorar los atributos asignados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(rieles)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"riel\"  \"viaje\"\n\n$class\n[1] \"nffGroupedData\" \"nfGroupedData\"  \"groupedData\"    \"data.frame\"    \n\n$row.names\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\"\n[16] \"16\" \"17\" \"18\"\n\n$labels\n$labels$y\n[1] \"Zero-force travel time\"\n\n\n$units\n$units$y\n[1] \"(nanoseconds)\"\n\n\n$formula\ntravel ~ 1 | Rail\n\n$order.groups\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nAhora cambiemos estos atributos para que todo esté expresado en español\ny de paso corregir la fórmula, que tal como está, pierde la referencia\nadecuada a las variables que contiene la tabla, pues yo cambié los\nnombres de las variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrieles  <- update(rieles, formula = viaje ~ 1 | riel, FUN = mean,\n                  labels = list(y = \"Tiempo de viaje con fuerza cero\"),\n                  units = list(y = \"(nano segundos)\"))\n\n# Encontré un detallito raro de atributos que se quedan con basura. \n# Aunque no parecen producir ningún problema, esta es una manera de limpiarla.\nattributes(attributes(rieles)$formula)$\".Environment\" <- environment()\nenvironment(attributes(rieles)$FUN) <- environment()\nattributes(rieles)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"riel\"  \"viaje\"\n\n$row.names\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\"\n[16] \"16\" \"17\" \"18\"\n\n$class\n[1] \"nffGroupedData\" \"nfGroupedData\"  \"groupedData\"    \"data.frame\"    \n\n$formula\nviaje ~ 1 | riel\n\n$labels\n$labels$y\n[1] \"Tiempo de viaje con fuerza cero\"\n\n\n$units\n$units$y\n[1] \"(nano segundos)\"\n\n\n$FUN\nfunction (x, ...) \nUseMethod(\"mean\")\n\n$order.groups\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nA esta tabla se le ha aplicado la función `groupedData` con la fórmula:\n\nviaje \\~ 1 \\| riel\n\nEsta estrategia permite darle mantenimiento a los metadatos, que\nincluyen indicaciones sobre el agrupamiento de los datos en la tablas.\nPara aprovechar esta estructura podemos usar funciones especiales, por\ncierto, dentro del paquete `nmle`, puedes averiguar un poco más al\nrespecto con `help(plot.nmGroupedData)`:\n\n-   `gapply` - aplica funciones por grupos\n-   `gsummary` - calcula los resúmenes de datos por grupos\n\nPor lo pronto veamos los datos en una gráfica con el factor *riel* que\ndefine los *renglones* cualitativos sobre los que se grafican los datos\ncuantitativos de *velocidad de viaje*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(rieles, aes(x = viaje, y = riel, group = riel)) + \n       geom_point(shape = 19, size = 4, color = \"blue\") +\n       labs(title = \"Análisis de integridad estructural de rieles\") +\n       xlab(label = \"tiempo de viaje (ns)\") +\n       ylab(label = \"riel\") +\n       theme(text = element_text(size = 18), \n             axis.text.x = element_text(angle = 0, hjust = 1)) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n[¿Cómo se ven estos datos? ¿qué piensas que habría que\nhacer?]{style=\"color:GoldenRod\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngsummary(rieles)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  riel    viaje\n2    2 31.66667\n5    5 50.00000\n1    1 54.00000\n6    6 82.66667\n3    3 84.66667\n4    4 96.00000\n```\n\n\n:::\n:::\n\n\n¿Cómo se asigna la estructura de agrupación a una tabla de datos? Como\ndije al principio, se puede usar la función groupedData de la biblioteca\n*nlme*. Hagamos un ahora un ensayo de este proceso.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrieles.sg <- as.data.frame(rieles)\n```\n:::\n\n\nEstructura de la tabla **sin** información de agrupamiento:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(rieles.sg) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t18 obs. of  2 variables:\n $ riel : Ord.factor w/ 6 levels \"2\"<\"5\"<\"1\"<\"6\"<..: 3 3 3 1 1 1 5 5 5 6 ...\n $ viaje: num  55 53 54 26 37 32 78 91 85 92 ...\n```\n\n\n:::\n:::\n\n\nLos atributos que contiene este objeto son estos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(rieles.sg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"riel\"  \"viaje\"\n\n$row.names\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\"\n[16] \"16\" \"17\" \"18\"\n\n$class\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\nTomo los datos sin agrupamiento y proporciono los *metadatos* que\ndefinen la **estructura de agrupamiento** que caracterizan a la tabla :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrieles.g <- groupedData (viaje ~ 1 | riel, data = rieles.sg, \n                         FUN = mean,\n                         units = list( x = \"(ns)\"),\n                         labels = list(x = \"riel\", \n                                       y = \"tiempo de tránsito de fuerza cero\"),\n                         )\nstr(rieles.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'nffGroupedData', 'nfGroupedData', 'groupedData' and 'data.frame':\t18 obs. of  2 variables:\n $ riel : Ord.factor w/ 6 levels \"2\"<\"5\"<\"1\"<\"6\"<..: 3 3 3 1 1 1 5 5 5 6 ...\n $ viaje: num  55 53 54 26 37 32 78 91 85 92 ...\n - attr(*, \"formula\")=Class 'formula'  language viaje ~ 1 | riel\n  .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n - attr(*, \"labels\")=List of 2\n  ..$ x: chr \"riel\"\n  ..$ y: chr \"tiempo de tránsito de fuerza cero\"\n - attr(*, \"units\")=List of 1\n  ..$ x: chr \"(ns)\"\n - attr(*, \"FUN\")=function (x, ...)  \n - attr(*, \"order.groups\")= logi TRUE\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(sg = rieles.sg, g = rieles.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   sg.riel sg.viaje g.riel g.viaje\n1        1       55      1      55\n2        1       53      1      53\n3        1       54      1      54\n4        2       26      2      26\n5        2       37      2      37\n6        2       32      2      32\n7        3       78      3      78\n8        3       91      3      91\n9        3       85      3      85\n10       4       92      4      92\n11       4      100      4     100\n12       4       96      4      96\n13       5       49      5      49\n14       5       51      5      51\n15       5       50      5      50\n16       6       80      6      80\n17       6       85      6      85\n18       6       83      6      83\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngsummary(rieles.sg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    riel viaje\n26     2    26\n32     2    32\n37     2    37\n49     5    49\n50     5    50\n51     5    51\n53     1    53\n54     1    54\n55     1    55\n78     3    78\n80     6    80\n83     6    83\n85     3    85\n91     3    91\n92     4    92\n96     4    96\n100    4   100\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngsummary(rieles.g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  riel    viaje\n2    2 31.66667\n5    5 50.00000\n1    1 54.00000\n6    6 82.66667\n3    3 84.66667\n4    4 96.00000\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(rieles.g, aes(x = viaje, y = riel, group = riel)) + \n       geom_point(shape = 19, size = 4, color = \"blue\") +\n       labs(title = \"Análisis de rieles (rieles.g)\") +\n       xlab(label = attr(rieles.g, \"labels\")$y) +\n       ylab(label = \"riel\") +\n       theme(text = element_text(size = 18), \n             axis.text.x = element_text(angle = 0, hjust = 1)) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nComo hemos visto, cambiar los metadatos de la tabla se hace con la\nfunción `update()`.\n\nComo una demostración simple de esto, le cambiaré la etiqueta, que es un\natributo asociado a la variable de respuesta en la estructura de\nagrupamiento. El dato lo puedo recuperar entonces con la funcción `attr`\npara \"labels\". En seguida te pongo un ejemplo\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrieles.g1 <- update(rieles.g, labels = list(y = \"tiempo (ns)\"))\n\nggplot(rieles.g1, aes(x = viaje, y = riel, group = riel)) + \n       geom_point(shape = 19, size = 4, color = \"blue\") +\n       labs(title = \"Análisis de rieles (rieles.g1)\") +\n       xlab(label = attr(rieles.g1, \"labels\")$y) +\n       ylab(label = \"riel\") +\n       theme(text = element_text(size = 18), \n             axis.text.x = element_text(angle = 0, hjust = 1)) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nPrimera posibilidad de análisis. Modelo lineal simple. Es una elección\nnatural en este caso, pues estima la media general. Hay que recordar\nseleccionar contrastes de tipo \"tratamiento\" aun para factores\nordenados.\n\n[¿Cómo representamos al riel en el modelo?]{style=\"color:GoldenRod\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions ()$contrasts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        unordered           ordered \n\"contr.treatment\"      \"contr.poly\" \n```\n\n\n:::\n:::\n\n\nEmpecemos por construir el modelo nulo. [¿qué resultados nos ofrece este\nmodelo?]{style=\"color:GoldenRod\"}.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrieles.m1 <- lm(viaje ~ 1, data =rieles.g)\nsummary(rieles.m1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = viaje ~ 1, data = rieles.g)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-40.50 -16.25   0.00  18.50  33.50 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   66.500      5.573   11.93  1.1e-09 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 23.65 on 17 degrees of freedom\n```\n\n\n:::\n:::\n\n\nAsí, tengo una estimación del tiempo promedio de tránsito de: 66.5. El\nerror estándar que estimo es: 5.573\n\n[¿cómo quedan los residuos de este modelo?]{style=\"color:GoldenRod\"}\n\nEl gráfico de *cajas y bigotes* o *cajas y alambres* es interesante para\nexplorar lo que está pasando con los rieles.\n\n[¿Qué piensas de esta gráfica? ¿Te gusta lo que\nves?]{style=\"color:GoldenRod\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(rieles.g, aes(x = viaje, y = riel, group = riel)) + \n       stat_boxplot(geom ='errorbar', linetype = 2, width = 0.5) + \n       geom_boxplot(shape = 19, size = 0.5, color = \"blue\") +\n       labs(title = \"Análisis de rieles (rieles.g)\") +\n       xlab(label = \"tiempo de viaje (ns)\") +\n       ylab(label = \"riel\") +\n       theme(text = element_text(size = 18), \n             axis.text.x = element_text(angle = 0, hjust = 1)) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nAl ignorar el efecto de los rieles, dentro de los que repito la prueba\npara obtener las medidas de interés se produce un defecto que se ve\nclaramente en esta gráfica de residuos.\n\nLos residuos de cada riel tienen todos el mismo signo. Es decir se\nmantiene un efecto sistemático importante en ellos.\n\n[Te parecería buena idea agregar el término que representa al riel para\nresolver este problema?]{style=\"color:GoldenRod\"}\n\n[¿Es fijo o aleatorio?]{style=\"color:GoldenRod\"}\n\nEste nuevo modelo permite que cada riel sea representado por una media\ndiferente. Suponiendo efectos fijos, la estimación del parámetro de\ninterés es esta.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrieles.m2 <- lm(viaje ~ riel - 1, data = rieles.g)\nrieles.m2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = viaje ~ riel - 1, data = rieles.g)\n\nCoefficients:\nriel2  riel5  riel1  riel6  riel3  riel4  \n31.67  50.00  54.00  82.67  84.67  96.00  \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(rieles.m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nResponse: viaje\n          Df Sum Sq Mean Sq F value    Pr(>F)    \nriel       6  88911 14818.5  916.61 2.971e-15 ***\nResiduals 12    194    16.2                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(rieles.m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = viaje ~ riel - 1, data = rieles.g)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-6.6667 -1.0000  0.1667  1.0000  6.3333 \n\nCoefficients:\n      Estimate Std. Error t value Pr(>|t|)    \nriel2   31.667      2.321   13.64 1.15e-08 ***\nriel5   50.000      2.321   21.54 5.86e-11 ***\nriel1   54.000      2.321   23.26 2.37e-11 ***\nriel6   82.667      2.321   35.61 1.54e-13 ***\nriel3   84.667      2.321   36.47 1.16e-13 ***\nriel4   96.000      2.321   41.35 2.59e-14 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.021 on 12 degrees of freedom\nMultiple R-squared:  0.9978,\tAdjusted R-squared:  0.9967 \nF-statistic: 916.6 on 6 and 12 DF,  p-value: 2.971e-15\n```\n\n\n:::\n:::\n\n\n[¿interpretación de este nuevo resultado?]{style=\"color:GoldenRod\"}\n\n........... [¿y los residuos? ¿cómo se ven\nahora?]{style=\"color:GoldenRod\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres.m2 <- data.frame(resid = resid(rieles.m2), riel = rieles.g$riel)\nggplot(res.m2, aes(x = resid, y = riel, group = riel)) + \n       stat_boxplot(geom = 'errorbar', linetype = 2, width = 0.5) + \n       geom_boxplot(shape = 19, size = 0.5, color = \"blue\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nA pesar de que el modelo remueve los efectos sistemáticos asociados a\nlas características particulares de los distintos rieles, no proporciona\nuna representación satisfactoria del problema.\n\n[si los rieles fueran de efectos fijos ¿qué implicaría este modelo?\n¿cuál sería una interpretación razonable del tratamiento\n**riel**?]{style=\"color:GoldenRod\"}\n\nAl suponer efectos fijos surge el problema de que se modelan de algún\nmodo *variantes individuales* de los rieles que se usaron para realizar\nlas pruebas. Desafortunadamente, tal clasificación no tiene ningún\nsentido en el contexto. Lo que interesa es estimar el tiempo de tránsito\ntípico de cualquier riel en la *población de rieles* de la que se tomó\nla muestra.\n\nAdemás, la misma falta de correspondencia conceptual entre el modelo y\nla estimación que interesa, hace que este nuevo modelo no proporcione\nuna clara estimación de la variación (componente de varianza), entre\nrieles, que es otra de las preguntas centrales de este estudio. Otro\nproblema de este modelo de efectos fijos es que el número de parámetros\ncrece linealmente con el número de rieles que se usan para realizar la\nprueba, generando un comportamiento extraño en el modelo respecto de la\npregunta.\n\n#### El Modelo de efectos aleatorios ¿resuelves estos problemas?.\n\nEn este enfoque se considera a los rieles como un efecto aleatorio sobre\nla media general. Hay principalmente dos métodos para ajustar este tipo\nde modelos el de máxima verosimilitud (ML) y el de máxima verosimilitud\nrestringida (REML, default). La función que utilizaremos para el caso\nlineal es `lme()` que se usa de modo muy semejante a `lm()`. Sin\nembargo, nótese que ahora el modelo tiene dos grupos de fórmulas, una\npara describir los efectos fijos (opción *fixed*) y otra para describir\nlos aleatorios (opción *random*). Esté último es siempre una fórmula que\ntiene sólo el lado derecho (no hay interés en predecir medias,\n¿recuerdas?) y da cuenta de los efectos aleatorios y de la estructura de\nagrupamiento de los datos. Un agrupamiento se representa mediante el\nsímbolo de barra vertical: `|`. Ahora, ajustemos un modelo de este tipo\npara obtener la estimación de *máxima verosimilitud restringida* para\nlos rieles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrieles.m3 <- lme(fixed = viaje ~ 1,\n                 random = ~ 1 | riel,\n                 data = rieles.g)\nrieles.m3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed-effects model fit by REML\n  Data: rieles.g \n  Log-restricted-likelihood: -61.0885\n  Fixed: viaje ~ 1 \n(Intercept) \n       66.5 \n\nRandom effects:\n Formula: ~1 | riel\n        (Intercept) Residual\nStdDev:    24.80547 4.020779\n\nNumber of Observations: 18\nNumber of Groups: 6 \n```\n\n\n:::\n:::\n\n\n::: {.callou-caution style=\"color:GoldenRod\"}\n## Ayúdame a comentar estos resultados ¿qué te llama la atención?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(rieles.m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed-effects model fit by REML\n  Data: rieles.g \n      AIC      BIC   logLik\n  128.177 130.6766 -61.0885\n\nRandom effects:\n Formula: ~1 | riel\n        (Intercept) Residual\nStdDev:    24.80547 4.020779\n\nFixed effects:  viaje ~ 1 \n            Value Std.Error DF  t-value p-value\n(Intercept)  66.5  10.17104 12 6.538173       0\n\nStandardized Within-Group Residuals:\n        Min          Q1         Med          Q3         Max \n-1.61882658 -0.28217671  0.03569328  0.21955784  1.61437744 \n\nNumber of Observations: 18\nNumber of Groups: 6 \n```\n\n\n:::\n:::\n\n:::\n\nEl ajuste produce los estimadores que buscamos: 1. tiempo de tránsito\ntípico = 66.5 2. Variabilidad entre rieles = 24.81 3. Variabilidad\ndentro de rieles = 4.02\n\nEn este caso los estimadores 1 y 3 son prácticamente idénticos a los\nobtenidos con el modelo lineal ordinario, pero esto no siempre es así.\nLa coincidencia deriva de que la muestra está balanceada (mismo tamaño\nde muestra en cada riel). Además, ahora tengo un razonable estimador de\nla variación entre rieles (2).\n\n[¿Qué utilidad pueden tener estas\nestimaciones?]{style=\"color:GoldenRod\"}\n\nEl resumen del ajuste muestra dos criterios nuevos para comparar y\nevaluar modelos. Estas medidas son resultado de la búsqueda de\nalternativas para valorar modelos que no se centre en el famoso valor de\n*p*.\n\n-   AIC - Criterio de información de Akaike = -2 \\* logVerosimilitud + 2\n    numParámetros\n-   BIC - Criterio de información bayesiano = -2 \\* logVerosimilitud +\n    numParámetros \\* log(N)\n\nPara interpretar el Criterio de Información de Akaike (AIC) al comparar\nmodelo, lo que hacemos es valorar la diferencia en el AIC que se asocia\na los modelos que queremos comparar. Si queremos ser muy formales le\npodemos llamar a eso la ($\\Delta \\text{AIC} = AIC_{i}-AIC_{0}$). Como\n*regla de dedo* podemos recurrir a lo siguiente, que se ha venido\nestableciendo como práctica común, no hay mayor fundamento que eso. Como\nya hemos venido haciendo, podemos iniciar por construir el modelo con\ntodas las variables que previmos, el modelo completo. Este modelo\nproducirá el AIC más pequeño y lo podemos tomar como referencia inicial.\ntomamos el modelo de referencia. Ahora, el tamaño de la diferencia la\npodemos interpretar así:\n\n-   $\\Delta AIC \\le 2$: Podemos pensar que los modelos explican casi por\n    igual el sistema y puedo optar por considerarlos equivalentes. La\n    diferencia es despreciable.\n-   $+2<\\Delta AIC\\le 4$: Sugiere que posiblemente el modelo reducido\n    (mayor AIC) ajusta bien a los datos, aunque sí hay una ligera\n    pérdida, al contrastarlo con lo que logra el modelo más comolejo.\n-   $4<\\Delta AIC\\le 7$: Si ocurre esto, el modelo reducido sigue\n    teniendo soporte defendible en su ajuste a los datos, pero hay ya\n    una pérdida marcada al comparar lo aue logra el modelo comoleto.\n-   $\\Delta AIC>10$: Esta amgnitud de perdida de ajuste a los datos\n    sugiere aue el modelo reducido en cuesión tiene nulo o\n    insignificante apoyo.\n\nOtros criterios de juicio. Desde luego siempre se prefiere el modelo con\nel AIC más bajo. Por el principio de parsimonia, si dos modelos tienen\nun $\\Delta AIC$ muy bajo ($\\le 2$), se suele preferir el más simple (el\nque tenga menos parámetros).Tamaño de muestra ((AICc)): Si el tamaño de\nla muestra es pequeño en comparación con el número de parámetros\n($N/K<40$), es mejor utilizar el AIC corregido ($AICc$) para evitar\nsobreajuste.\n\nEs bueno contar con ellos para comparar la calidad general de los\nmodelos ajustados, pero no olviden que centrar nuestra atención en los\nintervalos de confianza es más informativo y potencialmente interesante.\nFinalmente, veamos los residuos\n\n[¿Cómo se ven?]{style=\"color:GoldenRod\"}\n\n[¿Qué nos sugieren estos resultados?]{style=\"color:GoldenRod\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(rieles.g, aes(x = resid(rieles.m3), y = riel, group = riel)) + \n       stat_boxplot(geom='errorbar', linetype = 2, width = 0.5) + \n       geom_boxplot(shape = 19, size = 0.5, color = \"blue\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\nPuedo obtener los estimadores de los coeficientes igual que en el caso\n`lm()` con `coef()`, pero además puedo obtener los coeficientes de los\ncomponentes aleatorios con `random.effects()` (forma breve: `ranef()`).\n\n¿Que hay de los intervalos de confianza de los parámetros de efectos\nfijos estimados?.\n\nComo he venido insistiendo, esta forma de mostrar resultados es cada vez\nmás apreciada y es más conveniente que el enfoque de uso de valores de\n\"*p*\" en las publicaciones. La función `intervals()` supone un nivel de\nconfianza del 95%, si no se le dice otra cosa.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef(rieles.m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  (Intercept)\n2    31.96909\n5    50.14325\n1    54.10852\n6    82.52631\n3    84.50894\n4    95.74388\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nranef(rieles.m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  (Intercept)\n2   -34.53091\n5   -16.35675\n1   -12.39148\n6    16.02631\n3    18.00894\n4    29.24388\n```\n\n\n:::\n:::\n\n\n[¿Qué piensas de estos estimadores de intervalos de\nconfianza?]{style=\"color:GoldenRod\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintervals(rieles.m3, 0.95)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nApproximate 95% confidence intervals\n\n Fixed effects:\n               lower est.    upper\n(Intercept) 44.33921 66.5 88.66079\n\n Random Effects:\n  Level: riel \n                   lower     est.    upper\nsd((Intercept)) 13.27436 24.80547 46.35335\n\n Within-group standard error:\n   lower     est.    upper \n2.695012 4.020779 5.998737 \n```\n\n\n:::\n:::\n\n\n\n![](images/ratas-de-lab.png){width=400}\n\n## Control del glucógeno en hígados de rata\n\nEste ejemplo fue presentado originalmente en Sokal & Rohlf (1981). Se\ntrata de un experimento con un solo factor con tres dietas: 1 =\n\"control\", 2 = \"compuesto 217\", 3 = \"compuesto 217 + azúcar\". Fueron\nadministrados a seis ratas, dos por tratamiento. El análisis se complica\npor el hecho de que, para el análisis, se tomaron tres muestras del\nhígado de cada rata y se hicieron dos determinaciones de contenido de\nglucógeno en cada muestra. Podríamos decir, un tanto despectivamente,\nque hay seis **pseudoréplicas** por rata para dar un total de 36\nlecturas en total. Pero quizás en lugar de hablar en estos términos\ndeberíamos simplemente reconocer que lo que estamos haciendo es\norganizar un muestreo dentro del estudio (lo que genera algo de\nvariación aleatoria), para obtener el dato de la variable de respuesta\nen el experimento, que es distinto a lo usual de hacer una \"cosecha\ntotal\", que es la práctica ideal (pues evita introducir un fuente de\n\"ruido\" adicional).\n\n[Datos del\nexperimento](https://drive.google.com/file/d/1NYuQYRR-ZKy_wlqylIHk_W6wKN10LoHy/view?usp=sharing)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas_g <- read.table(\"hígados-rata.DAT\", col.names = \"glucogeno\")\nratas_g$tratamiento <- factor(rep(c(\"t1\",\"t2\",\"t3\"),each = 12))\nratas_g$rata <- factor(rep(paste(\"r\", 1:6, sep = \"\"), each = 6))\nratas_g$muestraH <- factor(rep(c(\"m1\", \"m2\", \"m3\"), times = 6, each = 2))\n```\n:::\n\n\nLe doy estructura de grupos a la tabla\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas_g <- groupedData(glucogeno ~  1 | ordered(rata) / muestraH,\n                       data = ratas_g,\n                       labels = list(x = \"rata\", y = \"contenido de glucógeno\" ),\n                       FUN = mean)\nstr(ratas_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'nmGroupedData', 'groupedData' and 'data.frame':\t36 obs. of  4 variables:\n $ glucogeno  : int  131 130 131 125 136 142 150 148 140 143 ...\n $ tratamiento: Factor w/ 3 levels \"t1\",\"t2\",\"t3\": 1 1 1 1 1 1 1 1 1 1 ...\n $ rata       : Factor w/ 6 levels \"r1\",\"r2\",\"r3\",..: 1 1 1 1 1 1 2 2 2 2 ...\n $ muestraH   : Factor w/ 3 levels \"m1\",\"m2\",\"m3\": 1 1 2 2 3 3 1 1 2 2 ...\n - attr(*, \"formula\")=Class 'formula'  language glucogeno ~ 1 | ordered(rata)/muestraH\n  .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n - attr(*, \"formulaList\")=List of 2\n  ..$ ordered(rata):Class 'formula'  language ~ordered(rata)\n  .. .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n  ..$ muestraH     :Class 'formula'  language ~muestraH\n  .. .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n - attr(*, \"labels\")=List of 2\n  ..$ x: chr \"rata\"\n  ..$ y: chr \"contenido de glucógeno\"\n - attr(*, \"order.groups\")=List of 2\n  ..$ ordered(rata): logi TRUE\n  ..$ muestraH     : logi TRUE\n - attr(*, \"FUN\")=function (x, ...)  \n```\n\n\n:::\n:::\n\n\n### Exploración de los datos\n\nAprovechando las opciones de estructura de grupos puedo obtener\nresúmenes exploratorios de manera muy simple.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(promedio = tapply(ratas_g$glucogeno, ratas_g$rata, function(x) round(mean(x), 2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   promedio\nr1   132.50\nr2   148.50\nr3   149.67\nr4   152.33\nr5   134.33\nr6   136.00\n```\n\n\n:::\n:::\n\n\nGraficación de los datos aprovechando la estructura agrupada que hemos\nadoptado.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas_g <- ratas_g |>\n  mutate(r_m = paste0(rata,\"/\", muestraH)) |>\n  arrange(r_m) |>\n  mutate(r_m = ordered(r_m))\n\n\nggplot(ratas_g, aes(x = glucogeno, y = r_m)) + \n       geom_point(shape = 19, size = 2, color = \"blue\") +\n       scale_y_discrete(limits = rev) +\n       labs(title = \"Análisis de efecto de dieta en glucógeno\") +\n       xlab(label = \"glucógeno\") +\n       ylab(label = \"rata/muestra\") +\n       theme(text = element_text(size = 18), \n             axis.text.x = element_text(angle = 0, hjust = 1)) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(ratas_g, aes(x = tratamiento, y = glucogeno)) + \n       stat_boxplot(geom = 'errorbar', linetype = 2, width = 0.5) + \n       geom_boxplot(shape = 19, size = 0.5, color = \"blue\", notch = TRUE) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNotch went outside hinges\nℹ Do you want `notch = FALSE`?\nNotch went outside hinges\nℹ Do you want `notch = FALSE`?\nNotch went outside hinges\nℹ Do you want `notch = FALSE`?\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n### Modelación\n\nVeamos el enfoque con un modelo lineal de efectos mixtos.\n\n::: {.callou-caution style=\"color:GoldenRod\"}\n## ¿Cual es la estructura fija?, me puedes decir cuál es la ecuación correspondiente\n:::\n\nLa estructura aleatoria de los datos, cuando tiene varias fuentes, se\nrepresenta como una lista de efectos (modelos) en la función `lme()` de\nla biblioteca `nlme`. Otra posibilidad es usar la biblioteca `lme4` que\ncontiene a la función `lmer()`. Al respecto, [esta lectura puede ser de\ninnterés](http://staff.pubhealth.ku.dk/~jufo/courses/rm2018/nlmePackage.pdf)\n\nEste caso, como ya vimos, hay dos cosas en operación:\n\n1.  Hay una muestra aleatoria de ratas distintas en cada tratamiento.\n    Cabe esperar un valor promedio de glucógeno distinto para cada\n    animal. Esto lo representaré en el primer componente de la lista.\n2.  Hay una muestra aleatoria de fragmentos de hígado tomados de cada\n    rata. Esperamos que estas muestras estimen una misma cantidad de\n    glucógeno para cada animal. Esto lo representaré en el segundo\n    componente de la lista.\n\nEn el código siguiente tanto el modelo \"1\" como el \"2\" son equivalente.\nLos presento como dos formas interamiables para escribir el modelo de\nefectos aleatorios. Hay que notar que **no es correcto** hacer\ncomparaciones entre modelos que cambian en cuanto al componente \"fijo\"\n**si el ajuste se hace mediante el método \"REML\"**, en caso de tener\nhipótesis de interés en esta parte del modelo hay que emplear el método\n\"ML\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas.lme.m1 <- lme(fixed = glucogeno ~ tratamiento - 1,\n                    random = list(rata = ~ 1, muestraH = ~ 1),\n                    data = ratas_g)\n\nsummary(ratas.lme.m1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed-effects model fit by REML\n  Data: ratas_g \n       AIC      BIC    logLik\n  231.6213 240.6003 -109.8106\n\nRandom effects:\n Formula: ~1 | rata\n        (Intercept)\nStdDev:    6.005399\n\n Formula: ~1 | muestraH %in% rata\n        (Intercept) Residual\nStdDev:    3.763863 4.600725\n\nFixed effects:  glucogeno ~ tratamiento - 1 \n                 Value Std.Error DF  t-value p-value\ntratamientot1 140.5000  4.707166  3 29.84811   1e-04\ntratamientot2 151.0000  4.707166  3 32.07875   1e-04\ntratamientot3 135.1667  4.707166  3 28.71509   1e-04\n Correlation: \n              trtmn1 trtmn2\ntratamientot2 0            \ntratamientot3 0      0     \n\nStandardized Within-Group Residuals:\n        Min          Q1         Med          Q3         Max \n-1.48211987 -0.47263005  0.03061539  0.42934293  1.82934636 \n\nNumber of Observations: 36\nNumber of Groups: \n              rata muestraH %in% rata \n                 6                 18 \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas.lme.m2 <- lme(fixed = glucogeno ~ tratamiento - 1,\n                    random = ~ 1 | rata / muestraH,\n                    data = ratas_g)\n\nsummary(ratas.lme.m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed-effects model fit by REML\n  Data: ratas_g \n       AIC      BIC    logLik\n  231.6213 240.6003 -109.8106\n\nRandom effects:\n Formula: ~1 | rata\n        (Intercept)\nStdDev:    6.005399\n\n Formula: ~1 | muestraH %in% rata\n        (Intercept) Residual\nStdDev:    3.763863 4.600725\n\nFixed effects:  glucogeno ~ tratamiento - 1 \n                 Value Std.Error DF  t-value p-value\ntratamientot1 140.5000  4.707166  3 29.84811   1e-04\ntratamientot2 151.0000  4.707166  3 32.07875   1e-04\ntratamientot3 135.1667  4.707166  3 28.71509   1e-04\n Correlation: \n              trtmn1 trtmn2\ntratamientot2 0            \ntratamientot3 0      0     \n\nStandardized Within-Group Residuals:\n        Min          Q1         Med          Q3         Max \n-1.48211987 -0.47263005  0.03061539  0.42934293  1.82934636 \n\nNumber of Observations: 36\nNumber of Groups: \n              rata muestraH %in% rata \n                 6                 18 \n```\n\n\n:::\n:::\n\n\nPara comparar el efecto del tratamiento hay que usar el método \"ML\" y\najustar los modelos que contrastan la hipótesis de interés en el\ncomponente fijo.\n\nModelo \"nulo\" en cuanto a efectos fijos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(ratas_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'nmGroupedData', 'groupedData' and 'data.frame':\t36 obs. of  5 variables:\n $ glucogeno  : int  131 130 131 125 136 142 150 148 140 143 ...\n $ tratamiento: Factor w/ 3 levels \"t1\",\"t2\",\"t3\": 1 1 1 1 1 1 1 1 1 1 ...\n $ rata       : Factor w/ 6 levels \"r1\",\"r2\",\"r3\",..: 1 1 1 1 1 1 2 2 2 2 ...\n $ muestraH   : Factor w/ 3 levels \"m1\",\"m2\",\"m3\": 1 1 2 2 3 3 1 1 2 2 ...\n $ r_m        : Ord.factor w/ 18 levels \"r1/m1\"<\"r1/m2\"<..: 1 1 2 2 3 3 4 4 5 5 ...\n - attr(*, \"formula\")=Class 'formula'  language glucogeno ~ 1 | ordered(rata)/muestraH\n  .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n - attr(*, \"formulaList\")=List of 2\n  ..$ ordered(rata):Class 'formula'  language ~ordered(rata)\n  .. .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n  ..$ muestraH     :Class 'formula'  language ~muestraH\n  .. .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n - attr(*, \"labels\")=List of 2\n  ..$ x: chr \"rata\"\n  ..$ y: chr \"contenido de glucógeno\"\n - attr(*, \"order.groups\")=List of 2\n  ..$ ordered(rata): logi TRUE\n  ..$ muestraH     : logi TRUE\n - attr(*, \"FUN\")=function (x, ...)  \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas.lme.m3 <- lme(fixed = glucogeno ~ 1,\n                    random = ~1 | rata/muestraH, method = \"ML\",\n                    data = ratas_g)\nratas.lme.m3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed-effects model fit by maximum likelihood\n  Data: ratas_g \n  Log-likelihood: -119.8834\n  Fixed: glucogeno ~ 1 \n(Intercept) \n   142.2222 \n\nRandom effects:\n Formula: ~1 | rata\n        (Intercept)\nStdDev:    7.561272\n\n Formula: ~1 | muestraH %in% rata\n        (Intercept) Residual\nStdDev:    3.763863 4.600725\n\nNumber of Observations: 36\nNumber of Groups: \n              rata muestraH %in% rata \n                 6                 18 \n```\n\n\n:::\n:::\n\n\nModelo \"completo\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas.lme.m4 <- lme(fixed = glucogeno ~ tratamiento,\n                    random = ~1 | rata/muestraH, method = \"ML\",\n                    data = ratas_g) \nratas.lme.m4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed-effects model fit by maximum likelihood\n  Data: ratas_g \n  Log-likelihood: -116.6353\n  Fixed: glucogeno ~ tratamiento \n  (Intercept) tratamientot2 tratamientot3 \n   140.500000     10.500000     -5.333333 \n\nRandom effects:\n Formula: ~1 | rata\n        (Intercept)\nStdDev:    3.729149\n\n Formula: ~1 | muestraH %in% rata\n        (Intercept) Residual\nStdDev:    3.763794 4.600775\n\nNumber of Observations: 36\nNumber of Groups: \n              rata muestraH %in% rata \n                 6                 18 \n```\n\n\n:::\n:::\n\n\nAsí podemos comparar el análisis con modelos mixtos y el convencional en\ncuanto al efecto del tratamiento.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(ratas.lme.m4, ratas.lme.m3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             Model df      AIC      BIC    logLik   Test  L.Ratio p-value\nratas.lme.m4     1  6 245.2705 254.7716 -116.6353                        \nratas.lme.m3     2  4 247.7667 254.1008 -119.8834 1 vs 2 6.496197  0.0388\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas.completo.lm <- lm(glucogeno~tratamiento/rata/muestraH, data = ratas_g)\nanova(ratas.completo.lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nResponse: glucogeno\n                          Df  Sum Sq Mean Sq F value    Pr(>F)    \ntratamiento                2 1557.56  778.78 36.7927 4.375e-07 ***\ntratamiento:rata           3  797.67  265.89 12.5617 0.0001143 ***\ntratamiento:rata:muestraH 12  594.00   49.50  2.3386 0.0502907 .  \nResiduals                 18  381.00   21.17                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n### Intervalos de confianza\n\nEs importante contar con intervalos de confianza para describir de mejor\nmanera los resultados obtenidos. La forma de hacerlo para cada tipo de\nmodelo pude varia, así que ilustraré un par de rutas para obtenerlos.\n\n## Modelo de efectos mixtos: `lme`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas.lme4.ic <- predict(ratas.lme.m4, level = 0, type = \"predict\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas.lme4.ic  <- data.frame(ajustado = as.numeric(ratas.lme4.ic), \n                             tratamiento = ratas_g$tratamiento)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintervals(ratas.lme.m4)$fixed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   lower       est.      upper\n(Intercept)   133.507297 140.500000 147.492703\ntratamientot2  -4.479979  10.500000  25.479979\ntratamientot3 -20.313312  -5.333333   9.646646\nattr(,\"label\")\n[1] \"Fixed effects:\"\n```\n\n\n:::\n:::\n\n\n#### Modelo de regresión convencional: lm\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas.lm.ic <- as.data.frame(predict(ratas.completo.lm, interval = 'confidence',\n                                     conf.level = 0.95, ci.fit = TRUE))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratas.lm.ic$tratamiento <- ratas_g$tratamiento\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(min = tapply(ratas.lm.ic$lwr, ratas.lm.ic$tratamiento, mean),\n           media = tapply(ratas.lm.ic$fit, ratas.lm.ic$tratamiento, mean),\n           max = tapply(ratas.lm.ic$upr, ratas.lm.ic$tratamiento, mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        min    media      max\nt1 133.6653 140.5000 147.3347\nt2 144.1653 151.0000 157.8347\nt3 128.3319 135.1667 142.0014\n```\n\n\n:::\n:::\n\n\nBueno, veamos los residuos!!! Lo primero es recuperar lo necesario del\nmodelo, con la función `residuals`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame( resid = residuals(ratas.lme.m4, type = \"pearson\"), \n                  tratamiento = ratas_g$tratamiento, \n                  rata = ratas_g$rata ) \n\n# Gráfica de cajas de residuos por factor (ej. Sexo) \n\nggplot(df, aes(x = resid, y = rata)) + \n  geom_boxplot(fill = \"skyblue\", alpha = 0.6) + \n  facet_wrap(~ tratamiento) +\n  labs(title = \"Residuos del modelo lme para rata/tratamientos\", \n       y = \"rata\", \n       x = \"Residuos (Pearson)\") +\n  theme_gray()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(ratas.lme.m4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n\n### Comparaciones múltiples\n\nVeamos qué está pasando con los efectos de los tratamientos una vez que\nhemos resuelto con la *prueba ómnibus* que hay algún efecto de\ntratamiento.\n\nEl modelo completo, ¿cambia significativamente al *recodifcar* los\ntratamientos de manera que supongamos que el *t1* no difiere del *t2*?\nEsto equivale a comparar los dos modelos respectivos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse, warn.conflicts = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ lubridate 1.9.4     ✔ tibble    3.3.1\n✔ purrr     1.2.1     ✔ tidyr     1.3.2\n✔ readr     2.1.6     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ nlme::collapse() masks dplyr::collapse()\n✖ dplyr::filter()  masks stats::filter()\n✖ dplyr::lag()     masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nratas_g$trat_v1 <- recode_factor(ratas_g$tratamiento, \"t2\" = \"t1\")\nratas.lme.m4A <- lme(fixed = glucogeno ~ trat_v1,\n                     random = ~ 1 | rata / muestraH, method = \"ML\",\n                     data = ratas_g) \n\nratas_g$trat_v2 <- recode_factor(ratas_g$tratamiento, \"t3\" = \"t2\")\nratas.lme.m4B <- lme(fixed = glucogeno ~ trat_v2,\n                     random = ~ 1 | rata / muestraH, method = \"ML\", \n                     data = ratas_g) \n\nratas_g$trat_v3 <- recode_factor(ratas_g$tratamiento, \"t3\" = \"t1\")\nratas.lme.m4C <- lme(fixed = glucogeno ~ trat_v3,\n                     random = ~ 1 | rata / muestraH, method = \"ML\", \n                     data = ratas_g) \nhead(ratas_g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGrouped Data: glucogeno ~ 1 | ordered(rata)/muestraH\n  glucogeno tratamiento rata muestraH   r_m trat_v1 trat_v2 trat_v3\n1       131          t1   r1       m1 r1/m1      t1      t1      t1\n2       130          t1   r1       m1 r1/m1      t1      t1      t1\n3       131          t1   r1       m2 r1/m2      t1      t1      t1\n4       125          t1   r1       m2 r1/m2      t1      t1      t1\n5       136          t1   r1       m3 r1/m3      t1      t1      t1\n6       142          t1   r1       m3 r1/m3      t1      t1      t1\n```\n\n\n:::\n:::\n\n\n[¿Qué sugieren estos resultados estadísticos?]{style=\"color:GoldenRod\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(ratas.lme.m4A, ratas.lme.m4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              Model df      AIC      BIC    logLik   Test L.Ratio p-value\nratas.lme.m4A     1  5 246.8941 254.8117 -118.4471                       \nratas.lme.m4      2  6 245.2705 254.7716 -116.6353 1 vs 2 3.62358   0.057\n```\n\n\n:::\n:::\n\n\nPreguntémonos lo mismo respecto de los tratamientos *t2* y *t3*. Veamos\nlo que resulta al comparar los modelos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(ratas.lme.m4B, ratas.lme.m4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              Model df      AIC      BIC    logLik   Test  L.Ratio p-value\nratas.lme.m4B     1  5 249.6292 257.5467 -119.8146                        \nratas.lme.m4      2  6 245.2705 254.7716 -116.6353 1 vs 2 6.358622  0.0117\n```\n\n\n:::\n:::\n\n\nAhora los tratamientos *t1* y *t3*. ¿qué resulta al comparar los\nmodelos?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(ratas.lme.m4C, ratas.lme.m4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              Model df      AIC      BIC    logLik   Test  L.Ratio p-value\nratas.lme.m4C     1  5 244.4339 252.3514 -117.2169                        \nratas.lme.m4      2  6 245.2705 254.7716 -116.6353 1 vs 2 1.163313  0.2808\n```\n\n\n:::\n:::\n\n\n::: {.callou-caution style=\"color:GoldenRod\"}\n##¿Qué decisión tomarás?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(ratas.lme.m4C)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            numDF denDF  F-value p-value\n(Intercept)     1    18 4261.316  <.0001\ntrat_v3         1     4    8.116  0.0464\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintervals(ratas.lme.m4)$fixed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   lower       est.      upper\n(Intercept)   133.507297 140.500000 147.492703\ntratamientot2  -4.479979  10.500000  25.479979\ntratamientot3 -20.313312  -5.333333   9.646646\nattr(,\"label\")\n[1] \"Fixed effects:\"\n```\n\n\n:::\n:::\n\n:::\n\nQuizás es más interesante ver los resultados en términos de los valores\nestimados para cada tratamiento, en lugar de sobre sus diferencias.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(data.frame(trat_1 = intervals(ratas.lme.m4)$fixed[1,],\n             trat_2 = colSums(intervals(ratas.lme.m4)$fixed[1:2,]),\n             trat_3 = colSums(intervals(ratas.lme.m4)$fixed[1:3,])))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          lower     est.    upper\ntrat_1 133.5073 140.5000 147.4927\ntrat_2 129.0273 151.0000 172.9727\ntrat_3 108.7140 145.6667 182.6193\n```\n\n\n:::\n:::\n\n\nSi optáramos por tomar al modelo **C** como nuestro modelo mínimo\nadecuado para describir el experimento de glucógeno, los resultados se\nverían así:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(ratas.lme.m4C)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            numDF denDF  F-value p-value\n(Intercept)     1    18 4261.316  <.0001\ntrat_v3         1     4    8.116  0.0464\n```\n\n\n:::\n:::\n\n\nEste modelo sugiere que es posible argumentar que el tratamiento\ncombinando **t1** y **t3** difiere en forma apreciable o significativa\ncon respecto del **t2**. Esto se aprecia al considerar los valores\npromedio de los tratamientos, pero no es realmente muy evidente. La\nforma como estoy calculando los valores tiene que considerar el tipo de\nreparametrización y la configuración del modelo, no olvides eso.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnivel_confianza <- 0.90\nt(data.frame(trat_1 = intervals(ratas.lme.m4, level = nivel_confianza)$fixed[1,],\n             trat_2 = colSums(intervals(ratas.lme.m4, level = nivel_confianza)$fixed[1:2,]),\n                 trat_3 = colSums(intervals(ratas.lme.m4, level = nivel_confianza)$fixed[1:3,])))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          lower     est.    upper\ntrat_1 134.7283 140.5000 146.2717\ntrat_2 134.1509 151.0000 167.8491\ntrat_3 117.7401 145.6667 173.5932\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(data.frame(trat_1_y_3 = intervals(ratas.lme.m4C, level = nivel_confianza)$fixed[1,],\n             trat_2 = colSums(intervals(ratas.lme.m4C, level = nivel_confianza)$fixed[1:2,])))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              lower     est.    upper\ntrat_1_y_3 133.3366 137.8333 142.3300\ntrat_2     136.9281 151.0000 165.0719\n```\n\n\n:::\n:::\n\n\n# Modelo de las manos\n\nHagamos juntos aquí en clase el reanálisis del ejemplo de las manos como\nun modelo de efectos mixto. Pero, háganlo usteds y yo los veo.\n\n::: callout-note\n## El modelo puede ser este\n\n$$\ny_{ijk} = \\mu +  L_i + \\eta_{j(i)} + \\varepsilon_{k(ij)}\n$$\n\n-   ¿Te parece adecuado?\n-   ¿Lo puedes explicar?\n:::\n\nEn caso de que no tengas los datos de las manos por ahí, te recuerdo\ncomo obtenerlos de nuestro repositorio en Google drive.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nurl_manos <- \"https://drive.google.com/file/d/1GSQMbbX7szydnIMDkWYDBlFBWqTdkC4k/view?usp=drive_link\"\ndat_manos_id <- str_extract(url_manos, \"(?<=d/)(.*)(?=/view)\")\n\nurl_drive <- \"https://docs.google.com/uc?id=%s&export=download\" \nmanos <- read.csv(sprintf(url_drive, dat_manos_id)) \n```\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}